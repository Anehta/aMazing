#include "MazeGenerator.h"


MazeGenerator* MazeGenerator::instance = nullptr;

MazeGenerator::MazeGenerator()
{
	srand(time(nullptr));
}


MazeGenerator::~MazeGenerator()
{
}

MazeGenerator& MazeGenerator::getInstance()
{
	if (instance == nullptr)
	{
		instance = new MazeGenerator;
	}
	return *instance;
}

std::vector<std::vector<int> > MazeGenerator::GenerateWalls(int width, int height)
{
	std::vector<std::vector<int> > walls;
	int i = 0, total = height * width;
	int wall_temp[4] = { 1, 1, 1, 1 };
	std::vector<int> wall(wall_temp, wall_temp + sizeof(wall_temp) / sizeof(int));

	for (; i < total; i++) {
		walls.push_back(wall);
	}

	return walls;
}

void MazeGenerator::genMazeRecuresion(Maze* result, int px, int py)
{
	for (int i = 0;i<result->width;i++)
	{
		for (int j = 0;j<result->height;j++)
		{
			printf("%d ",result->get(i,j));
		}
		printf("\n");
	}
	printf("\n");
	if (!checkPoint(result,px,py))
	{
		return ;
	}
	if (result->get(px,py) == 0)
	{
		return ;
	}
	result->get(px, py) = 0;
	int dir[4] = { 0, 1, 2, 3 };
	int loop_times = rand() % 10;
	for (int i = 0; i < loop_times; i++)
	{
		int f = rand() % 4;
		int s = rand() % 4;
		int t = dir[f];
		dir[f] = dir[s];
		dir[s] = t;
	}

	for (auto d : dir)
	{
		switch (d)
		{
		case 0: 
			px += 1;
			if (!checkPoint(result, px, py) && (result->get(px, py) != 0))
				break;
			if (!checkPoint(result, px + 1, py) && (result->get(px + 1, py) != 0))
				break;
			if (!checkPoint(result, px, py + 1) && (result->get(px, py + 1) != 0))
				break;
			if (!checkPoint(result, px, py - 1) && (result->get(px, py - 1) != 0))
				break;
			result->get(px, py) = 0;
			genMazeRecuresion(result, px, py);
			break;
		case 1:
			px -= 1;
			if (!checkPoint(result, px, py) && (result->get(px, py) != 0))
				break;
			if (!checkPoint(result, px - 1, py) && (result->get(px - 1, py) != 0))
				break;
			if (!checkPoint(result, px, py + 1) && (result->get(px, py + 1) != 0))
				break;
			if (!checkPoint(result, px, py - 1) && (result->get(px, py - 1) != 0))
				break;
			result->get(px, py) = 0;
			genMazeRecuresion(result, px, py);
			break;
		case 2:
			py += 1;
			if (!checkPoint(result, px, py) && (result->get(px, py) != 0))
				break;
			if (!checkPoint(result, px, py + 1) && (result->get(px, py + 1) != 0))
				break;
			if (!checkPoint(result, px + 1, py) && (result->get(px + 1, py) != 0))
				break;
			if (!checkPoint(result, px - 1, py) && (result->get(px - 1, py) != 0))
				break;
			result->get(px, py) = 0;
			genMazeRecuresion(result, px, py);
			break;
		case 3:
			py -= 1;
			if (!checkPoint(result, px, py) && (result->get(px, py) != 0))
				break;
			if (!checkPoint(result, px, py - 1) && (result->get(px, py - 1) != 0))
				break;
			if (!checkPoint(result, px + 1, py) && (result->get(px + 1, py) != 0))
				break;
			if (!checkPoint(result, px - 1, py) && (result->get(px - 1, py) != 0))
				break;
			result->get(px, py) = 0;
			genMazeRecuresion(result, px, py);
			break;
		}
	}
}

Maze* MazeGenerator::genMaze(int dimension)
//get a new Maze generated by MazeGenerator
{
	Maze* output = nullptr;
	output = new Maze;
	if (output == nullptr)
	{
		return nullptr;
	}
	output->width = dimension;
	output->height = dimension;
	output->m_map = new bool[dimension * dimension];
	for (int i = 0; i<dimension * dimension; i++)
	{
		output->m_map[i] = true;
	}
	genMazeRecuresion(output, dimension / 2, dimension / 2);
	return output;
}

bool MazeGenerator::checkPoint(Maze* ref,const std::pair<int, int>& pt)
{
	if (pt.first >= 0 && pt.second >= 0)
	{
		if (pt.first < ref->width && (pt.second < ref->height))
		{
			return true;
		}
	}
	return false;
}


bool MazeGenerator::checkPoint(Maze* ref, int a, int b)
{
	if (a >= 0 && b >= 0)
	{
		if (a < ref->width && (b < ref->height))
		{
			return true;
		}
	}
	return false;
}
