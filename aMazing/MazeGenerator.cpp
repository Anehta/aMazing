#include "MazeGenerator.h"


MazeGenerator* MazeGenerator::instance = nullptr;

MazeGenerator::MazeGenerator()
{
}


MazeGenerator::~MazeGenerator()
{
}

MazeGenerator& MazeGenerator::getInstance()
{
	if (instance == nullptr)
	{
		instance = new MazeGenerator;
	}
	return *instance;
}

std::vector<std::vector<int> > MazeGenerator::GenerateWalls(int width, int height)
{
	std::vector<std::vector<int> > walls;
	int i = 0, total = height * width;
	int wall_temp[4] = { 1, 1, 1, 1 };
	std::vector<int> wall(wall_temp, wall_temp + sizeof(wall_temp) / sizeof(int));

	for (; i < total; i++) {
		walls.push_back(wall);
	}

	return walls;
}

void MazeGenerator::genMazeRecuresion(Maze* result,int l, int t, int r, int b)
{
	int x, y;
	int width = r - l;
	int height = b - t;
	if (width <= 2 || height <= 2)
		return;
	x = l + (rand() % width);
	y = t + (rand() % height);

	genMazeRecuresion(result, l, t, x - 1, y - 1);
	genMazeRecuresion(result, x + 1, t, r, y - 1);
	genMazeRecuresion(result, l, y + 1, x - 1, b);
	genMazeRecuresion(result, x + 1, y + 1, r, b);

	int dice = rand() % 4;
	if (dice != 0){ result->get(x,t + (rand() % (height / 2))) = true; }
	if (dice != 1){ result->get(l + (rand() % (width / 2)),y) = true; }
	if (dice != 2){ result->get(x,t + (height & 1) + (height / 2) + (rand() % (height / 2))) = true; }
	if (dice != 3){ result->get(l + (width & 1) + (width / 2) + (rand() % (width / 2)),y) = true; }
}

Maze* MazeGenerator::genMaze(int dimension)
//get a new Maze generated by MazeGenerator
{
	Maze* output = nullptr;
	output = new Maze;
	if (output == nullptr)
	{
		return nullptr;
	}
	output->width = dimension;
	output->height = dimension;
	output->m_map = new bool[dimension * dimension];
	memset(output->m_map, 0, sizeof(bool)* dimension * dimension);
	genMazeRecuresion(output,0,0,dimension - 1,dimension - 1);
	return output;
}